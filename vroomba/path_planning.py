import rclpy
from rclpy.node import Node
import numpy as np
from std_msgs.msg import Float64MultiArray
from  scipy.spatial import Delaunay
from .data_structs.Pos import Point
from queue import PriorityQueue
from ugrdv_kobuki_msgs.srv import EnableDrive
from std_msgs.msg import Float64MultiArray
from ugrdv_kobuki_msgs.msg import ConeArray, Cone


# based on sim this creates nice path but obvs need to test on kobuki
BEAM_WIDTH = 3
MIN_PATH_LENGTH = 3 
MAX_NUM_CONES = 5
START_TIME = 0.0
RUN_TIME = 0.0
class Path(Node):
    orange_seen = False
    def __init__(self) -> None:
        super().__init__("path_calculator")
        self.get_logger().info('Path Planning node started')

        self.orange_seen = False

        self.cone_subscription = self.create_subscription(
            Float64MultiArray, 
            '/seen_cones', 
            self.beam_search_through_centroids_with_penalties, 
            1
        )
        self.velocity_publisher = self.create_publisher(
            Float64MultiArray, 
            '/velocity_info',
            1
        )
        START_TIME = self._getTime()


    def calculate_cost_with_penalties(
        self, 
        path: list, 
        centroids: np.array, 
        points: Float64MultiArray, 
        delaunay: Delaunay) -> float:
        '''
        This will calculate a cost for each path with included
        penelties for going off track or doing anything that we dont want.

        Args:
            path (list): A list of paths generated by beam search
            centroids (np.array): A np.array of centeriods from the deluannay triangulation
            points (Float64MultiArray): points from deluannay triangulation
            delaunay (Delaunay): The delunay of the track

        Returns:
            float: _description_
        '''
        cost = 0
        max_distance = np.max(np.linalg.norm(centroids - np.mean(centroids, axis=0), axis=1))
        for i in range(len(path) - 1):
            point_a = centroids[path[i]]
            point_b = centroids[path[i + 1]]
            segment_length = np.linalg.norm(point_a - point_b)
            cost += segment_length  # Base cost: distance between centroids

            # Calculate curvature penalty if there's a next segment
            if i < len(path) - 2:
                point_c = centroids[path[i + 2]]
                vector1 = point_b - point_a
                vector2 = point_c - point_b
                angle = np.arccos(np.clip(np.dot(vector1, vector2) / (np.linalg.norm(vector1) * np.linalg.norm(vector2)), -1.0, 1.0))
                curvature_penalty = 0 if np.isnan(angle) else np.pi - angle
                cost += curvature_penalty * 0.1  # Small penalty based on deviation from straight path

            # Check penalty for crossing vertices between cones of the same color
            triangle_a = delaunay.simplices[path[i]]
            triangle_b = delaunay.simplices[path[i + 1]]
            common_vertices = set(triangle_a).intersection(triangle_b)
            for vertex in common_vertices:
                if points.data[vertex, 2] == points.data[list(common_vertices)[0], 2]:  # Same-colored cones
                    cost += 5  # Large penalty for crossing vertices of same-colored cones

            relative_distance_a = np.linalg.norm(point_a - np.mean(centroids, axis=0)) / max_distance
            relative_distance_b = np.linalg.norm(point_b - np.mean(centroids, axis=0)) / max_distance
            if relative_distance_a > 0.5 or relative_distance_b > 0.5:
                cost += 1  # Penalty based on distance from the mean of centroids. IDK if this is needed

        return cost

    def beam_search_through_centroids_with_penalties(self, points: Float64MultiArray) -> None:
        """
        Perform a beam search through the centroids of the Delaunay triangulation with penalties for crossing boundaries.
        :param points: Input array of points [x, y, id].
        :param beam_width: Number of paths to keep at each step.
        :return: List of paths explored with their costs, sorted by cost.
        """
        if self.orange_seen and RUN_TIME > 10:
            self.get_logger().info('Seen orange')
            # Make sure car stops
            point = Float64MultiArray()
            point.data = [0.0, 0.0, 0.0]
            self.velocity_publisher.publish(point)
            # disable the drive train
            self.finished()

        beam_width = BEAM_WIDTH
        try:
            delaunay = Delaunay(points.data) 
        except:
            # I cant be asked to implement actual logic so this will do
            msg = Float64MultiArray()
            msg.data = [1.0,0.0,0.0]
            self.velocity_publisher.publish(msg)
            return

        # Calculate centroids of triangles
        centroids = []
        triangle_to_centroid = {}
        for i, simplex in enumerate(delaunay.simplices):
            vertices = points.data[simplex, :2]
            centroid = np.mean(vertices, axis=0)
            triangle_to_centroid[i] = len(centroids)
            centroids.append(centroid)

        centroids = np.array(centroids)

        # Find the starting centroid closest to (0, 0) to use for starting point of the beam search
        start_node = np.argmin(np.linalg.norm(centroids - np.array([0, 0]), axis=1))

        # Build adjacency graph for centroids
        centroid_neighbors = {i: set() for i in range(len(centroids))}
        for simplex_idx, simplex in enumerate(delaunay.simplices):
            for neighbor in delaunay.neighbors[simplex_idx]:
                if neighbor != -1:  # Neighbor exists
                    centroid_neighbors[triangle_to_centroid[simplex_idx]].add(triangle_to_centroid[neighbor])

        # Beam search through centroids
        pq = PriorityQueue()
        pq.put((0, -1, [start_node]))  # Start search from the closest centroid to (0, 0)

        all_paths = [] 

        while not pq.empty():
            current_cost, negative_length, current_path = pq.get()

            # Get the last node in the current path
            last_node = current_path[-1]

            for neighbor in centroid_neighbors[last_node]:
                if neighbor not in current_path:  # Avoid cycles
                    new_path = current_path + [neighbor]
                    new_cost = self.calculate_cost_with_penalties(new_path, centroids, points.data, delaunay)
                    pq.put((new_cost, -len(new_path), new_path))

            # Store the current path and cost if it's valid
            if len(current_path) > MIN_PATH_LENGTH:
                all_paths.append((current_cost, [centroids[idx] for idx in current_path]))

            # Keep only the top `beam_width` paths in the priority queue
            if pq.qsize() > beam_width:
                # Convert the queue into a sorted list, keep top `beam_width`, and reconstruct the queue
                top_paths = sorted([pq.get() for _ in range(pq.qsize())], reverse=True)[:beam_width]
                for cost, neg_length, path in top_paths:
                    pq.put((cost, neg_length, path))

        # Sort all paths by cost and return
        all_paths = sorted(all_paths, key=lambda x: x[0])

        # from the little visual i made for this, this should work and give centre points
        cost, path = all_paths[0]

        if len(path) == 0:
            point = Float64MultiArray()
            point.data = [0.0, 0.0, 0.0]
            self.velocity_publisher.publish(point)
        index = 0 ## just watn to check if first point works first befroe trying anything else

        point = Point()
        point.x = path[index][0]
        point.y = path[index][1]
        point.angle = np.arcsin(point.y / np.sqrt((point.x**2) + (point.y**2)))

        pointToGo = Float64MultiArray()
        msg.data = [path[index][0], path[index][1], point.angle]
        self.velocity_publisher.publish(pointToGo)
        RUN_TIME = self._getTime() - START_TIME

    def _getTime(self) -> float:
        return self.get_clock().now().to_msg()

    def finished(self) -> None:
        client = self.create_client(EnableDrive, "ugrdv_kobuki/enable_drive")
        while not client.wait_for_service(timeout_sec=1.0):
            self.get_logger().warn('Cannot find drive-train service, waiting')
        request = EnableDrive.Request()
        request.enable = False

        future = client.call_async(request)
        rclpy.spin_until_future_complete(self, future)
        if future.result() is None:
            self.get_logger().warn('Drive-train service call failed')

    
def main(args=None) -> None:
    """
    The entrypoint of the program, this will create the ROS2 node, tell the ROS2 runtime to 'spin' it
    and then shutdown gracefully when the node quits
    """
    print('Path planning started')
    rclpy.init(args=args)
    path_planning_node = Path()
    rclpy.spin(path_planning_node)
    rclpy.shutdown()


if __name__ == '__main__':
    main()
